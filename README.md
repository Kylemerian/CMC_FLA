# Минимизация ДКА

Необходимо скачать предоставленное окружение и реализовать функцию dfa_minim в файле task.cpp, принимающую в качестве аргумента детерминированный конечный автомат в виде DFA и возвращающую автомат с минимальным количеством состояний, задающий тот же язык, что и исходный автомат.

Окружение содержит реализации алфавита в виде класса Alphabet (этот класс позволяет автоматически получать алфавит, над которым задан автомат) и ДКА в виде класса DFA (этот класс помогает считать автомат в правильном формате). API этих классов приведен в файле api.hpp. Состояния в DFA идентифицируются непустыми строковыми именами, присваиваемыми им при создании.

Тестовые автоматы всегда корректны, детерминированы и задаются в следующем формате: на первой строке перечисляются все символы алфавита, затем на отдельных строчках перечисляются все состояния в формате "[имя_состояния]" или же "[[имя_состояния]]" для финальных состояний. Первое упомянутое состояние считается начальным. Затем перечисляются все переходы в автомате в формате "[имя_начального_состояния] символ_перехода [имя_конечного_состояния]", по одному переходу на строчку. Можно считать, что тестовые автоматы содержат не более 100 состояний.

Функция main в файле main.cpp считывает ДКА из файла dfa_minim.in, передает его в функцию dfa_minim, после чего выводит минимизированный автомат в текстовом виде в файл dfa_minim.out.

Сборка окружения выполняется с помощью CMake или bash-скрипта quick-setup.sh. Получаемый бинарный исполняемый файл – dfa_minim.

# Построение ДКА по регулярному выражению

Необходимо скачать предоставленное окружение и реализовать функцию re2dfa в файле task.cpp, принимающую в качестве аргумента корректное регулярное выражение s в виде std::string и возвращающую детерминированный конечный автомат в виде DFA, задающий тот же язык, что и регулярное выражение s.

Окружение содержит реализации алфавита в виде класса Alphabet (этот класс позволяет автоматически получать алфавит, над которым задано регулярное выражение) и ДКА в виде класса DFA (этот класс помогает вывести автомат в правильном формате). API этих классов приведен в файле api.hpp. Состояния в DFA идентифицируются непустыми строковыми именами, присваиваемыми им при создании.

Тестовые регулярные выражения всегда корректны и состоят из символов алфавита (в алфавит могут входить буквы латинского алфавита и цифры), скобок, | – операция объединения, * – итерация. Специальный символ пустой строки (эпсилон) не используется: выражение (ε|a)b* записывается как (|a)b*. Пустая строка считается регулярным выражением, задающим пустое слово, а не пустым регулярным выражением. Можно считать, что тестовые регулярные выражения содержат не более 1000 символов.

Функция main в файле main.cpp считывает регулярное выражение из файла re2dfa.in, передает его в функцию re2dfa, после чего выводит построенный ДКА в текстовом виде в файл re2dfa.out в следующем формате: на первой строке перечисляются все символы алфавита, затем на отдельных строчках перечисляются все состояния в формате "[имя_состояния]" или же "[[имя_состояния]]" для финальных состояний. Первое упомянутое состояние считается начальным. Затем перечисляются все переходы в автомате в формате "[имя_начального_состояния] символ_перехода [имя_конечного_состояния]", по одному переходу на строчку.

Сборка окружения выполняется с помощью CMake или bash-скрипта quick-setup.sh. Получаемый бинарный исполняемый файл – re2dfa.
# Примеры
- Входные данные в файле re2dfa.in

`a|b|ab`

- Результат работы в файле re2dfa.out

`ab`

`[0]`

`[[1]]`

`[[2]]`

`[0] a [1]`

`[0] b [2]`

`[1] b [2]`


- Входные данные в файле re2dfa.in

`
(|a)(bb)* 
`

- Результат работы в файле re2dfa.out

`ab`

`[[0]]`

`[[1]]`

`[2]`

`[0] a [1]`

`[0] b [2]`

`[1] b [2]`

`[2] b [1]`
